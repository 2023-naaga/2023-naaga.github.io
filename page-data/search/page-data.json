{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"작성자: 루카(github 링크) 🎯 글의 목적  서비스에 로그인 기능 구현 로그인 시 필요한 기술에 대한 학습 및 적용기에 대한 설명 더불어 팀원들에게 지식 전달 측면에서 작성하는 글 나아가 서버에서 소셜 로그인을 적용에 대해서 을 설명한다.  적용 방식을 설명한다. ❓소셜 로그인을 사용하는 이유 나아가 서비스 특성상 회원가입, 로그인 과정이 단순해야하…","fields":{"slug":"/oauth/"},"frontmatter":{"date":"August 24, 2023","title":"나아가, 소셜 로그인 적용기 (OAuth 2.0, JWT,  AccessToken, RefreshToken)","tags":["백엔드"]},"rawMarkdownBody":"\n\n작성자: 루카[(github 링크)](https://github.com/dooboocookie)\n\n## 🎯 글의 목적\n\n- `나아가` 서비스에 로그인 기능 구현\n    - 로그인 시 필요한 기술에 대한 학습 및 적용기에 대한 설명\n    - 더불어 팀원들에게 지식 전달 측면에서 작성하는 글\n- 나아가 서버에서 소셜 로그인을 적용에 대해서 `전체적인 흐름`을 설명한다.\n- `Access Token과 Refresh Token` 적용 방식을 설명한다.\n\n---\n\n## ❓소셜 로그인을 사용하는 이유\n\n- 나아가 서비스 특성상 회원가입, 로그인 과정이 단순해야하므로 소셜 로그인 기능 구현 필요\n- 사용자의 선택사항을 최대한으로 줄이기 위해서, `일단 카카오 소셜 로그인만` 적용할 예정\n\n---\n\n## 🔑 Oauth2.0 개념\n\n- OAuth 2.0은 인증을 위한 표준 프로토콜이다.\n- 다른 플랫폼(구글, 카카오, 깃헙, ...)의 `리소스` 접근 권한을 위임 받는 것이다.\n\n### 용어\n\n#### Resouce Server (자원 서버) & Authorization Server (권한 부여 서버)\n\n- 사용하고자 하는 자원을 보관하거나 접근 권하는 주는 서버를 의미한다.\n    - 구글, 카카오, 깃헙, ...\n- Resource Server\n    - 자원을 가지고 있는 서버\n- Authorization Server\n    - 자원에 접근할 권한(토큰)을 부여해주는 서버\n- RFC6749([링크](https://datatracker.ietf.org/doc/html/rfc6749#section-1.2)) 에 의하면 이 둘은 따로 보지만, 같이 두는 경우도 있음.\n\n#### Resouce Owner (자원의 소유자)\n\n- 사용하고자 `자원의 소유자`를 의미한다.\n    - 나아가로 예시를 들면,\n        - 나아가 앱을 사용하는 사용자\n        - 카카오에 회원정보(리소스)를 보관중인 사람\n\n#### Client (자원을 사용)\n\n- `자원을 사용`하고자 하는 주체를 의미한다\n    - 나아가로 예시를 들면,\n        - 나아가\n        - 나아가에서는 기본적인 회원 정보를 사용한다.\n\n### Oauth2.0의 흐름\n\n![](https://velog.velcdn.com/images/dooboocookie/post/e6a62bef-db83-41f8-a884-5f3a23838e39/image.png)\n\n(출처: https://blog.naver.com/mds_datasecurity/222182943542)\n\n#### 0. 클라이언트 등록\n\n![](슬라이드2.png)\n\n- Client가 Resource Server의 자원을 이용하기 위해 등록하는 과정이다.\n    - Resource Server에서 Client임을 식별하기 위한 정보가 필요하다. \n\n1. Redirect URI\n   - 로그인 인증 성공 시, 리다이렉트 시킬 위치를 지정하는 URI\n   - OAuth 과정에서 정보들(Authorization Code)을 다른 URI로 탈취당하지 않기 위함\n   - https만 허용\n\n2. Client ID, Client Secret\n   - Resource Server가 Client임을 식별하기 위한 장치\n   - Client Secret은 유출되지 않도록 조심\n\n#### 1. 로그인 요청 (로그인 페이지 보여주기)\n\n![](슬라이드3.png)\n\n- `OOO으로 로그인`하기 버튼을 누르거나 `로그인이 필요한 기능에 접근했을 때 리다이렉트로` 발생되는 요청이다.\n- `유저(리소스 오너)`가 `나아가(클라이언트)`에게 로그인 요청을 했을 때`카카오(리소스 서버)`로 로그인 요청을 보낸다.\n- 로그인 요청을 할 땐 아래 항목을 포함해서 보낸다.\n    - client_id: 어떤 클라이언트(나아가)임을 나타내는 정보\n    - scope: 리소스 오너(유저)가 동의한 리소스 항목\n    - redirect_uri: 인가 코드를 전달 받을 클라이언트(나아가)의 URI\n    - response_type: 응답을 어떤 타입으로 받을지 설정, 인가 코드로 응답을 받을 것이므로 code로 고정\n    - ...\n\n#### 2. 로그인 정보 제공하고 Authorization Code 발급 받기\n\n![](슬라이드4.png)\n\n- 리소스 오너(유저)는 리소스 서버(카카오)의 `로그인 페이지`를 제공 받고, 로그인 정보를 입력하거나 로그인된 정보를 제공한다.\n- Authorzation Code를 응답 받는다.\n- Redirect URI로 리다이렉트 된다.\n\n#### 3. Authorization Code ↔️ OAuth Access Token 교환\n\n![](슬라이드5.png)\n\n- Redirect된 나아가 서버에서 Authorization Code를 가지고, 권한 부여 서버로 Access Token을 발급 요청한다.\n- 권한 부여 서버가 Authorizaion Code에 대한 리소스 오너의 리소스로 접근 가능한 OAuth Access Token을 발급한다.\n\n#### 4. 로그인 처리\n\n![](슬라이드6.png)\n\n- 이제 클라이언트가 리소스 오너의 리소스를 리소스 서버로 부터 받아올 수 있는 OAuth Access Token이 있으므로 로그인 처리를 하면 된다.\n- 세션을 사용하던, JWT를 사용하던 사용자(리소스 오너)에게 로그인이 되었다는 응답을 준다.\n\n#### 5. Access Token 으로 정보 조회\n\n![](https://velog.velcdn.com/images/dooboocookie/post/1e0c64c3-cb29-49ae-ac43-d75155d67012/image.png)\n\n- 필요 시 리소스 서버로부터 리소스 오너의 리소스가 필요하다면 3번에서 발급받은 Access Token을 사용하면된다.\n\n---\n\n## 🪙 Token 방식 (JWT)\n\n### JWT 개념\n- JSON Web Token\n- JSON 형식으로 쉽게 읽히고 해석되기 위한 토큰\n- 필요한 정보에 대해서 자체적으로 가지고 있다.\n    - 회원에 대한 정보, 유효기간,  ...\n    - 서버에 유저 상태를 필수적으로 저장할 필요는 없다.\n    - 서버 확장에 용이하다.\n\n### JWT 구조\n![](https://i2.wp.com/www.opennaru.com/wp-content/uploads/2018/08/JWT_Stacks.png?zoom=2&fit=1200%2C300)\n\n- JWT는 `헤더`, `페이로드`, `서명`으로 구성되어 있고, `점(.)`으로 구분한다.\n\n#### 1. 헤더\n\n- 토큰 타입이나 알고리즘에 대한 정보를 포함한다.\n- Base64Url로 인코딩된다.\n\n```\n{\n  \"alg\": \"HS512\",\n  \"typ\": \"JWT\"\n}\n```\n\n#### 2. 페이로드\n\n- Claims이라고 불리는 토큰 자체 데이터를 포함한다.\n    - Registered claims: 유효기간(exp), 토큰의 대상(sub), 발행처(iss), 발행 시간(iat), ...\n    - Public claims: IANA JWT Registry에 등록해서 다른 조직과 충돌을 피하고자 하는 공용 claims을 등록한다.\n    - Prviate claims: 사용자의 권한 정보 같이 어플리케이션 내에서만 사용되는 클레임을 나타낸다.\n- Base64Url로 인코딩한다.\n\n```\n{\n  \"sub\": \"{\\\"memberId\\\":1,\\\"authId\\\":1,\\\"authType\\\":\\\"KAKAO\\\"}\",\n  \"exp\": 4845877047\n}\n```\n\n#### 3. 시그니처\n\n- 토큰의 무결성을 보장하는 정보를 포함한다.\n- 아래의 정보를 헤더에서 명시된 알고리즘으로 생성한다.\n    - 인코딩된 헤더.인코딩된 페이로드\n    - 시크릿 키\n\n```\nHMACSHA512(\n  base64UrlEncode(header) + \".\" + base64UrlEncode(payload),\n  시크릿 키\n)\n```\n\n### Access Token\n\n- 사용자의 권한을 나타내는 토큰\n- 토큰 자체로 토큰의 담겨있는 유저의 정보에 접근이 가능하다.\n- 탈취 위험성 때문에 토큰의 수명이 짧다.\n- stateless한 HTTP 통신에서 인증처리를 한 사용자임을 나타내기 위해 `Authorization` 헤더에 포함되어 요청이 간다.\n\n### Refresh Token\n- Access Token이 매우 짧은 수명을 갖고 있으므로, 그 시기마다 로그인 요청을 하지 않고 Refresh Token을 통해서 `Access Token을 재발급` 받기 위함이다.\n- Access Token에 비해 수명이 매우 길다.\n\n---\n\n## 📄 나아가 적용\n\n### 로그인 과정\n\n- OAuth와 JWT를 기반으로 로그인 기능을 구현한다.\n- 일단 나아가 같은 경우, 안드로이드 앱을 기반으로 한다.\n- 안드로이드 단에서는 Kakao SDK for Android([링크](https://developers.kakao.com/docs/latest/ko/kakaologin/android))를 기반으로 하여 로그인 기능을 구현하였다.\n    - 위 OAuth 흐름에서 설명했던 내용 중, 인가 코드를 카카오 액세스 토큰으로 교환하는 것 까지 안드로이드에서 일어난다.\n\n#### 1. 카카오에서 Kakao Access Token을 받아온다.\n\n![](슬라이드17.png)\n\n- 카카오에게 유저가 로그인 정보를 제공하고 Kakao AccessToken을 제공 받는다.\n\n#### 2. 나아가 서버로 로그인 요청\n\n![](슬라이드18.png)\n\n- 나아가의 로그인 처리를 위해서 카카오에서 받급받은 Kakao Access Token을 가지고 로그인 요청을 한다.\n\n```http\nPOST /auth\nContent-Type: application/json\n\n{\n\t\t\"token\": \"q1q2w2w3e3e4r4t5t6yu7u78\",\n\t\t\"type\": \"KAKAO\",\n}\n```\n\n#### 3. 카카오 서버로 부터 정보를 받아온다.\n\n![](슬라이드19.png)\n\n1. AuthClient 객체의 카카오와 통신하는 메서드 호출\n    - AuthClient: RestTemplate으로 외부 서버와 통신하는 객체\n2. 클라이언트로 부터 받은 Kakao Access Token으로 카카오 리소스 서버에게 유저 정보를 요청한다.\n    - API 문서 ➡️ [링크](https://developers.kakao.com/docs/latest/ko/kakaologin/rest-api#req-user-info)\n3. 2번 요청 시, 파라미터로 넘긴 정보 값들에 대해서 해당 사용자가 scope를 동의했으면, 유저 정보를 넘겨준다. (API 문서 참고)\n4. AuthInfo 객체를 생성해서 반환한다.\n    - 카카오에서 전달 받은 유저의 정보를 바인딩하기 위한 DTO이다.\n\n#### 4. 회원을 조회하거나 저장하거나\n\n![](슬라이드20.png)\n\n- AuthInfo 담겨 있는 email 정보를 토대로 해당 회원이 있는지 파악한다.\n    - 있으면, 해당 회원을 find 해온다.\n    - 없으면, 새로운 회원을 create 한다.\n\n#### 5. JWT 토큰 생성\n\n![](슬라이드21.png)\n\n- jjwt(JWT 라이브러리)를 이용하여 JWT 토큰을 생성한다.\n- Token의 유효성을 검사하기 위해 나아가만의 Secret key 정보도 JWT 시그니처에 포함시킨다.\n- 토큰의 Claims 정보는 다음과 같다.\n    - 회원의 아이디\n    - Oauth 인증처\n    - Oauth 서버에서 사용하는 회원 아이디\n    - 수명\n\n```\n{\n  \"sub\": \"{\\\"memberId\\\":1,\\\"authId\\\":1,\\\"authType\\\":\\\"KAKAO\\\"}\",\n  \"exp\": 4845877047\n}\n```\n\n- 수명\n    - Access Token은 30분\n    - Refresh Token은 14일\n- Access Token과 Refresh Token를 한 쌍으로 하는 AuthToken 엔티티 객체를 생성하여 반환한다.\n\n#### 6. JWT 토큰 저장\n\n![](슬라이드22.png)\n\n- 토큰은 5번에서 보여지듯 토큰 자체가 정보를 갖고 있고, 수명까지 가지고 있다.\n    - 그래서 서버는 유저의 로그인 정보인 토큰을 필수적으로 저장할 필요는 없다.\n    - 유저가 헤더에 담아오는 토큰 정보를 보고 어떤 회원인지 판단하면 된다.\n- 하지만, Refresh Token 관리를 위해서 서버에 저장하기로 결정했다.\n\n|id|access_token|refresh_token|member_id|\n|:---:|:---:|:---:|:---:|\n|1|4r324r3.13r344v.32r443|4r324r3.13r34f4.32r443|3|\n|2|4r324r3.3r234b4.32r443|4r324r3.3r234tg.32r443|4|\n|...|...|...|...|\n\n#### 7. 응답\n\n![](슬라이드23.png)\n\n- 이제 유저(안드로이드 앱)에게 Access Token과 Refresh Token이 전달되게 된다.\n    - 안드로이드 로컬 스토리지에 저장해 뒀다가, 인증 정보가 필요한 요청에는 Authorization 헤더에 해당 정보를 포함해서 보내면 된다.\n\n![](슬라이드24.png)\n\n- 전체적인 흐름\n\n### 인가 과정\n\n#### 1. Interceptor와 Argument Resolver\n- AuthInterceptor의 역할\n    - 인가 처리를 위해서 인증이 된 사용자인지를 확인하는 과정을 거친다.\n    - 인가가 필요한 요청URL을 매핑한다.\n\n```java\n    @Override\n    public void addInterceptors(final InterceptorRegistry registry) {\n        registry.addInterceptor(authInterceptor)\n                .addPathPatterns(\"/**\")\n                .excludePathPatterns(\"/h2-console/**\")\n                .excludePathPatterns(\"/auth/**\")\n                .excludePathPatterns(\"/**/*.png\", \"/**/*.jpg\", \"/**/*.jpeg\", \"/**/*.gif\", \"/**/*.ico\")\n                .excludePathPatterns(\"/ranks\");\n    }\n```\n\n- PlayerArgumentResolver의 역할\n    - 컨트롤러의 파라미터로 들어오는 PlayerRequest(플레이어 아이디)를 바인딩하기 위해 생각한다.\n\n```java\n    @Override\n    public boolean supportsParameter(final MethodParameter parameter) {\n        return parameter.hasParameterAnnotation(Auth.class)\n                && parameter.getParameterType().equals(PlayerRequest.class);\n    }\n```\n\n#### 2. AuthInterceptor에서 토큰 검증\n\n![](슬라이드26.png)\n\n- Authorization 헤더에 포함된 토큰 정보를 디코딩하며, 유효성을 검사한다.\n    - 수명이 아직 유효한지 확인한다.\n    - 시그니처의 시크릿 키가 일치하는지 확인한다.\n- 유효한 토큰이라고 확인이 되면, 인증된 회원이라고 인식하고 통과한다.\n\n#### 3. PlayerArgumentResolver에서 파라미터 바인딩\n\n![](슬라이드27.png)\n\n- Authorization 헤더에 포함된 토큰 정보를 디코딩하여, subject를 가져온다.\n\n![](슬라이드28.png)\n\n- subject에 포함된 memberId를 통해, PlayerService에서 Player를 가져온다.\n\n#### 4. Controller 도달\n\n![](슬라이드29.png)\n\n- 인가 처리와 파라미터 바인딩을 마치고 컨트롤러에 도달한다.\n\n### 토큰 갱신 (Refresh Token ➡️ Access Token 재발급)\n\n#### 0. Access Token 만료\n\n![](슬라이드30.png)\n\n- Access Token로 인가처리를 하다가 만료된 Access Token이면 `토큰이 만료되었다`는 예외를 응답한다.\n\n#### 1. Access Token 재발급 요청\n\n![](슬라이드31.png)\n\n- Access Token이 만료되었다는 응답을 받으면 Refresh Token을 가지고 토큰 재발급 요청을 한다.\n\n#### 2. 저장되어 있는 Refresh Token 인지 확인\n\n![](슬라이드32.png)\n\n- 나아가의 DB에 저장되어 있는 Refresh Token인지 확인한다.\n- 토큰의 유효성(수명, 시크릿 키)와는 상관 없이, DB에 저장되어 있는 Refresh Token만 사용가능한 토큰이라고 판단한다.\n\n#### 3. Refresh Token을 삭제\n\n![](슬라이드33.png)\n\n- 재발급 요청에 쓴 Refresh Token은 더이상 사용할 수 없는 토큰이므로 `무조건 삭제`한다.\n    - `올바른 사용자`, Refresh Token을 사용하여 새로운 Access Token과 Refresh Token을 발급할 것이므로 이전 토큰은 삭제한다.\n    - `올바르지 않은 사용자`, 탈취당하거나 이미 만료된 Refresh Token이라면 이 토큰은 더 이상 사용되면 안되는 토큰이므로 삭제한다.\n\n#### 4. 토큰 재발급\n\n![](슬라이드34.png)\n\n- Refresh Token에 대한 고민점\n    - Refresh Token으로 재발급 요청을 했을 때 무조건 Access Token을 재발급 해주면, Refresh Token이 기간이 긴 Access Token이라는 생각이 들었다.\n    - Refresh Token도 탈취 가능성이 있는데 어떤 검증을 해야할까?\n    - 현실적으로 어떤 검증을 할 수 있을지 고민했는데, 간단하게 `Access Token이 만료되지 않았는데 재발급 요청한 상황`은 해당 Refresh Token은 탈취되었다고 판단했다.\n- Access Token이 만료되었고, Refresh Token이 만료되지 않았다면 새로운 토큰 한 쌍을 발급하고 새로 저장한다.\n\n![](슬라이드35.png)\n\n#### 5. 응답\n\n![](슬라이드36.png)\n\n- 새로운 Access Token과 Refresh Token을 안드로이드로 응답한다.\n\n### 회원 탈퇴 & 로그아웃\n\n- 회원 탈퇴와 로그아웃 또한 API가 존재한다.\n\n#### 회원 탈퇴\n\n1. AuthToken(Refresh Token, Access Token) 삭제\n    - 이미 어딘가에 발급된 Refresh Token을 사용하지 못하게 하기 위함\n2. 회원 삭제\n3. 카카오에게 해당 회원 연결 끊기 요청 발송\n    - API 문서 ([링크](https://developers.kakao.com/docs/latest/ko/kakaologin/rest-api#unlink))\n#### 로그아웃\n\n1. AuthToken(Refresh Token, Access Token) 삭제\n    - 이미 어딘가에 발급된 Refresh Token을 사용하지 못하게 하기 위함\n2. 카카오에게 해당 회원 로그아웃 요청 발송\n    - API 문서 ([링크](https://developers.kakao.com/docs/latest/ko/kakaologin/rest-api#logout))\n\n#### 고려사항\n\n- 연결 끊기, 로그아웃 요청에서 Kakao Access Token 필요\n    - 현재 Kakao Access Token을 서버에서 보관하지 않는다.\n    - 그래서 JWT Access Token 내에 있는 Kakao id로 해당 요청들을 보내서 해당 회원이 연결을 끊고 로그아웃 했다고 알린다.\n\n---\n\n## 👍 마치며\n\n- OAuth 2.0과 JWT 토큰을 이용하여 로그인을 구현하였다.\n- 아직 고려할 점이 많다.\n    - 카카오 뿐 아니라 다른 소셜 로그인이 붙는다면 AuthClient, AuthInfo 추상화\n    - 더 안전한 Refresh Token을 통한 토큰 재발급 프로세스\n    - 카카오의 Access Token을 현재는 서버에 저장하지 않지만, 카카오의 리소스가 로그인 접속 시, 지속적으로 필요하면 저장할 필요가 있음\n- 개념적인 부분과 나아가 서버의 적용된 내용의 프로세스에 대해서 대략적으로 설명한다.\n    - 혹시 코드가 궁금하다면 여기([링크]())를 클릭해주세요.\n"},{"excerpt":"1. 포스트 추가하기  경로에 새로운 마크다운 파일을 생성하여 여러분의 글을 추가할 수 있습니다. 1-1. 포스트 파일 구조 새로운 문서를 추가하는 방법에는 두가지가 있습니다. 첫번째는 디렉토리 없이 문서를 생성하는 방법입니다. 만약 여러분이 Javascript 에 관한 문서를 생성한다면,  파일을  디렉토리에 추가할 수 있습니다. 두번째 방법은 먼저 디…","fields":{"slug":"/writing-guide-kr/"},"frontmatter":{"date":"April 03, 2021","title":"🤔 작성 가이드","tags":["hoodie","writing-guide"]},"rawMarkdownBody":"\n## 1. 포스트 추가하기\n\n`contents/post` 경로에 새로운 마크다운 파일을 생성하여 여러분의 글을 추가할 수 있습니다.\n\n### 1-1. 포스트 파일 구조\n\n새로운 문서를 추가하는 방법에는 두가지가 있습니다. 첫번째는 디렉토리 없이 문서를 생성하는 방법입니다. 만약 여러분이 Javascript 에 관한 문서를 생성한다면, `about-javascript.md` 파일을 `contents/posts` 디렉토리에 추가할 수 있습니다.\n\n두번째 방법은 먼저 디렉토리를 생성한 뒤, 디렉토리 안에 `index.md` 파일을 추가하는 것 입니다. 이 방법은 문서 내에 여러 이미지 파일 등 부수적인 파일 여러개가 포함되었을 때 유용합니다.\n\n첫번째 방법으로 생성한 파일명이나, 두번째 방법으로 생성한 디렉토리 이름은 웹사이트에서 고유의 주소를 갖습니다. `https://siteURL/about-javascript` 와 같이요.\n\n### 1-2. Frontmatter\n\n마크다운은 문서의 메타데이터인 Frontmatter 라 불리는 정보를 가지고 있습니다.\n\n```\n---\ntitle: \"🤔 3. 작성 가이드\"\ndescription: \"어떻게 글을 작성하고 추가할까요?\"\ndate: 2021-04-03\nupdate: 2021-04-03\ntags:\n  - hoodie\n  - writing-guide\nseries: \"gatsby-starter-hoodie 로 블로그 시작하기\"\n---\n```\n\n위는 지금 여러분이 읽고 있는 문서의 Frontmatter 입니다. `title` 과 `date` 는 필수 값입니다. 띄어쓰기를 포함된 문자열을 입력할 때에는 따옴표로 감싸는 것을 추천합니다.\n\n### 1-3. 마크다운 작성하기\n\n만약 Frontmatter 까지 작성했다면, 여러분은 그 아래에 마크다운 문서를 작성하면 됩니다. gatsby-starter-hoodie 는 대부분의 마크다운 문법을 지원합니다. 마크다운 작성 방법을 알고 싶다면, Github 의 [Mastering Markdown](https://guides.github.com/features/mastering-markdown/) 문서를 참고하세요.\n\n## 2. 코드 하이라이팅 & Katex\n\n### 2-1. 코드 하이라이팅\n\nPrism.JS 에 기반한 코드 하이라이팅이 제공됩니다.\n\n#### 예시\n\nJavascript\n\n```javascript\nconsole.log(\"Hello, world!\")\n```\n\nPython\n\n```python\nprint(\"Hello, world!\")\n```\n\n그 외 더 많은 언어를 제공합니다. 제공되는 언어를 확인하고 싶다면, [Prism.js 웹사이트](https://prismjs.com/) 를 참고하세요.\n\n### 2-2. Katex\n\nKatex 문법을 지원하여 복잡한 수식도 쉽게 표현할 수 있습니다.\n\n#### 인라인 모드\n\n$$E = m c^{2}$$\n\n#### 블럭 모드\n\n$$\n\\int_{0}^{\\infty} f(x) dx\n$$\n\n## 3. 글에 이미지 추가하기\n\n상대경로를 이용하여 쉽게 이미지를 추가할 수 있습니다. 디렉토리를 생성하고 그 안에 `index.md` 를 추가하여, 글을 추가하는 방법으로 작성해야 이미지 관리가 쉽습니다.\n\n![샘플 이미지 캡션](sample-image.jpg)\n\n이미지는 Lazy Loading 으로 로드되어, 빠른 초기 문서 로딩 속도를 확보할 수 있습니다.\n\n> ⚠ 이미지의 모든 확장자는 소문자여야합니다.\n\n## 4. 태그\n\n![](tag-example.jpg)\n\nFrontmatter 의 태그를 통해 쉽게 문서를 분류하고 검색할 수 있습니다. 여러분의 모든 태그는 `https://siteUrl/tags` 경로에서 확인하고, 검색할 수 있습니다.\n\n## 5. 시리즈\n\n![](series-example.jpg)\n\n여러분이 연관된 여러개의 문서를 작성할 때 시리즈를 사용할 수 있습니다. Frontmatter 에 작성된 시리즈가 같은 문서끼리 묶여 문서 상단에 리스트로 표시됩니다. 시리즈는 일련의 순서가 있는 문서들을 작성할 때 유용하게 사용할 수 있습니다. 시리즈는 문서의 작성 날짜 순서대로 정렬됩니다.\n\n현재 문서는 `gatsby-starter-hoodie 로 블로그 시작하기` 라는 시리즈로 설정되어 있습니다.\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}